# CS-340

***How do you write programs that are maintainable, readable, and adaptable? Especially consider your work on the CRUD Python module from Project One, which you used to connect the dashboard widgets to the database in Project Two. What were the advantages of working in this way? How else could you use this CRUD Python module in the future?***

One way in which I write programs that are maintainable, readable, and adaptable, is to use DRY coding principles (Don't Repeat Yourself).  I do my best to analyze my code to see if I can write any functions that will perform an operation a few times or several times, in lieu of having duplicate lines of code throughout a program.  Furthermore, I try to make sure my programs are modular, such that the entire program is not all in one file.  Furthermore, dynamic referencing of files within the program's file system is most often very useful in programs that will be maintained, used, or otherwise adapted by more than one person.  This allows for the program to run even if everything outside of the root program folder is altered.  For example, a graphics program which uses textures might have a textures folder, and that textures folder should be dynamically referenced when using texture files, as opposed to a static reference to a specific location within a specific drive (e.g., ...\textures\ as opposed to C:\user\myProgram\myGraphicsRender\textures).  I could use the CRUD module in the future for other web applications, data/aggregation pipelines, APIs, or really an endless amount of other applications.  Any functioning program with a database interface will require these four functions.

***How do you approach a problem as a computer scientist? Consider how you approached the database or dashboard requirements that Grazioso Salvare requested. How did your approach to this project differ from previous assignments in other courses? What techniques or strategies would you use in the future to create databases to meet other client requests?***

I try to approach a problem as a computer scientist by first specifically addressing the problem using critical thinking.  For instance, when someone tells me "My computer isn't working." I have to first ask "What, specifically, about your computer isn't working?".  I might get a response such as "Well, it won't turn on."  I then have to ask "Are you certain it's not on, or is the monitor perhaps just not displaying video?", and so on.  Once the real problem is actually identified, then I will compile a list of possible causes to the problem.  Once I have identified all of the possible causes (as far as my own knowledge allows) to the problem, I attempt to determine the actual cause using troubleshooting techniques.  Once the cause is idenitified, I compile a list of possible solutions, and analyze them to determine which solution is the most efficient, or practical.  This particular assignment differed from others in the past such that it had so many dependencies involved, none of which I had used, at least to any significant degree, prior to this class.  All of these dependencies had to work in concert to achieve the desired product outcome for the customer, and I would use the same strategy when doing full stack development for any client.  It is important to break each step down (problem, cause, solution) when solving any problem, and often to re-evaluate during the creation process as new information is discovered.

***What do computer scientists do, and why does it matter? How would your work on this type of project help a company, like Grazioso Salvare, to do their work better?***

I'm going to take this as more of a philosophical question, rather than a technical one, as it's plainly obvious what computer scientists do- so I suppose that I would say computer scientists make life easier by taking the most time consuming processes for humans, and automate them, or otherwise make them as efficient/intuitive as possible through programming.  Using our example of Grazioso Salvare, we have taken a process that, without computers, would require a massive centrally located file system, and we've condensed it into a computer program that's remotely accessible from anywhere in the world, usable by anyone in the world.  Applications such as this have eliminated the need (in most applications, not all) for expensive, space-consuming filing systems with thousands of pounds of paper products that require a clerk to maintain and use in order to provide information to clients.  We take the clerk and the file system, and we automate them, using specific prompts from a user in order to convey the desired information to the user in the most efficient, effective manner possible.
